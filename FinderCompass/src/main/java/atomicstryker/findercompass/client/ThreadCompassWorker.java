package atomicstryker.findercompass.client;import net.minecraft.client.Minecraft;import net.minecraft.core.BlockPos;import net.minecraft.world.level.block.state.BlockState;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import java.util.ArrayList;import java.util.List;/** * Runnable worker class for finding Blocks * * @author AtomicStryker */public class ThreadCompassWorker extends Thread {    private static final Logger LOGGER = LogManager.getLogger();    private Minecraft mcinstance;    private boolean isRunning = false;    private BlockState blockState;    private int playerX;    private int playerY;    private int playerZ;    private int xzRange;    private int yRange;    private int minY;    private int maxY;    public ThreadCompassWorker(Minecraft mc) {        mcinstance = mc;    }    public void setupValues(BlockState b, int pX, int pY, int pZ, int xzR, int yR, int mnY, int mxY) {        blockState = b;        playerX = pX;        playerY = pY;        playerZ = pZ;        xzRange = xzR;        yRange = yR;        minY = mnY;        maxY = mxY;    }    public boolean isWorking() {        return isRunning;    }    @Override    public void run() {        isRunning = true;        // search!        LOGGER.debug("compass worker started search for blockstate {} from player pos {}", blockState, new BlockPos(playerX, playerY, playerZ));        BlockPos result = findNearestBlockChunkOfIDInRange();        if (result != null) {            FinderCompassClientTicker.instance.onFoundChunkCoordinates(result, blockState);        }        isRunning = false;    }    private BlockPos findNearestBlockChunkOfIDInRange() {        List<BlockPos> blocksInRange = this.findBlocksOfIDInRange();        BlockPos playerCoords = new BlockPos(playerX, playerY, playerZ);        BlockPos resultCoords = new BlockPos(0, 0, 0);        double minDist = 9999.0D;        for (BlockPos coords : blocksInRange) {            double localDist = playerCoords.distSqr(coords);            if (localDist < minDist) {                resultCoords = coords;                minDist = localDist;                LOGGER.debug("Compassworker found stuff for block {} at coords {}, player distance {}", blockState.getBlock(), coords, minDist);            }        }        return resultCoords;    }    private List<BlockPos> findBlocksOfIDInRange() {        ArrayList<BlockPos> resultList = new ArrayList<>();        int counter = 0;        for (int yIter = playerY - yRange; yIter <= playerY + yRange + 1; ++yIter) {            if (yIter >= minY && yIter <= maxY) {                for (int zIter = playerZ - xzRange; zIter <= playerZ + xzRange; ++zIter) {                    for (int xIter = playerX - xzRange; xIter <= playerX + xzRange; ++xIter) {                        BlockState state = mcinstance.level.getBlockState(new BlockPos(xIter, yIter, zIter));                        counter++;                        if (state.getBlock() == blockState.getBlock()) {                            resultList.add(new BlockPos(xIter, yIter, zIter));                            LOGGER.trace("block match at {}! state match: {}", new BlockPos(xIter, yIter, zIter), state == blockState);                        }                        Thread.yield();                    }                }            } else {                LOGGER.debug("minY {} maxY {} yIter {} check failed, skipping", minY, maxY, yIter);            }        }        return resultList;    }}